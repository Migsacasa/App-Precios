generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  FIELD
  MANAGER
  ADMIN
}

enum Rating {
  GOOD
  REGULAR
  BAD
  NEEDS_REVIEW
}

enum Segment {
  LUBRICANTS
  BATTERIES
  TIRES
}

enum PhotoType {
  WIDE_SHOT
  SHELF_CLOSEUP
  OTHER
}

enum PiiRisk {
  NONE
  LOW
  MEDIUM
  HIGH
}

enum EvidenceType {
  VISIBILITY
  SHELF_SHARE
  PLACEMENT
  AVAILABILITY
  BRANDING
  PRICING
  OTHER
}

enum Severity {
  LOW
  MEDIUM
  HIGH
}

enum RecommendationPriority {
  P0
  P1
  P2
}

enum IndexSource {
  MANUAL
  AUTO_CALC
}

enum AuditAction {
  EVALUATION_CREATED
  EVALUATION_UPDATED
  EVALUATION_DELETED

  PHOTO_UPLOADED
  PHOTO_DELETED

  AI_EVALUATED
  AI_EVALUATION_FAILED

  MANAGER_OVERRIDE_APPLIED
  MANAGER_OVERRIDE_REMOVED

  STORE_IMPORT
  STORE_CREATED
  STORE_UPDATED

  PRODUCT_IMPORT
  PRODUCT_CREATED
  PRODUCT_UPDATED
  PRODUCT_PRICE_VERSIONED
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  name         String?
  role         Role     @default(FIELD)
  passwordHash String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  evaluations       Evaluation[]       @relation("EvaluationCreatedBy")
  overrides         Evaluation[]       @relation("EvaluationOverriddenBy")
  auditLogs         AuditLog[]         @relation("AuditActor")
  storeImports      StoreImportBatch[] @relation("StoreImportBy")
  priceVersionsMade ProductPriceVersion[] @relation("ProductPriceCreatedBy")

  @@index([role])
}

model StoreImportBatch {
  id           String   @id @default(uuid())
  fileName     String
  importedById String
  importedBy   User     @relation("StoreImportBy", fields: [importedById], references: [id])
  importedAt   DateTime @default(now())
  rowCount     Int
  meta         Json?

  stores       Store[]

  @@index([importedAt])
  @@index([importedById])
}

model Store {
  id           String   @id @default(uuid())
  customerCode String   @unique
  name         String

  chain        String?
  branch       String?
  city         String?
  zone         String?
  route        String?
  segmentLabel String?

  lat          Decimal  @db.Decimal(9,6)
  lng          Decimal  @db.Decimal(9,6)

  active       Boolean  @default(true)

  importBatchId String?
  importBatch   StoreImportBatch? @relation(fields: [importBatchId], references: [id])

  evaluations  Evaluation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([city, zone])
  @@index([active])
}

model Product {
  id        String   @id @default(uuid())
  sku       String   @unique
  name      String
  segment   Segment
  brand     String?
  category  String?
  active    Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  referencePhotos ProductReferencePhoto[]
  priceVersions   ProductPriceVersion[]

  @@index([segment])
  @@index([active])
}

model ProductReferencePhoto {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  url       String
  note      String?

  createdAt DateTime @default(now())

  @@index([productId])
}

model ProductPriceVersion {
  id          String   @id @default(uuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  currency    String   @default("NIO")
  ourPrice    Decimal  @db.Decimal(12,2)
  weight      Decimal? @db.Decimal(10,4)

  effectiveFrom DateTime
  effectiveTo   DateTime?

  createdById String
  createdBy   User     @relation("ProductPriceCreatedBy", fields: [createdById], references: [id])

  createdAt  DateTime @default(now())

  @@index([productId, effectiveFrom])
}

model Evaluation {
  id               String   @id @default(uuid())

  clientEvaluationId String? @unique

  storeId          String
  store            Store    @relation(fields: [storeId], references: [id])

  createdById      String
  createdBy        User     @relation("EvaluationCreatedBy", fields: [createdById], references: [id])

  capturedAt       DateTime
  submittedAt      DateTime @default(now())

  observedLat      Decimal? @db.Decimal(9,6)
  observedLng      Decimal? @db.Decimal(9,6)

  aiRating         Rating?
  aiScore          Int?
  aiConfidence     Float?
  finalRating      Rating?
  needsReview      Boolean  @default(false)

  overrideReason   String?
  overriddenById   String?
  overriddenBy     User?    @relation("EvaluationOverriddenBy", fields: [overriddenById], references: [id])
  overriddenAt     DateTime?

  hasPhotos        Boolean  @default(false)
  latestPhotoThumbUrl String?

  photos           EvaluationPhoto[]
  segmentIndices   EvaluationSegmentIndex[]

  aiEvaluation     AiEvaluation?
  aiFindings       AiFinding[]
  aiRecommendations AiRecommendation[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([storeId, capturedAt])
  @@index([createdById, capturedAt])
  @@index([finalRating, capturedAt])
  @@index([needsReview, capturedAt])
}

model EvaluationPhoto {
  id           String    @id @default(uuid())
  evaluationId String
  evaluation   Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  photoType    PhotoType
  url          String
  thumbnailUrl String?
  redactedUrl  String?

  width        Int?
  height       Int?
  byteSize     Int?
  sha256       String?

  piiRisk      PiiRisk   @default(NONE)

  capturedAt   DateTime?
  deletedAt    DateTime?

  createdAt    DateTime @default(now())

  @@index([evaluationId])
  @@index([photoType])
  @@index([deletedAt])
}

model EvaluationSegmentIndex {
  id            String   @id @default(uuid())
  evaluationId  String
  evaluation    Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  segment       Segment
  slot          Int

  currency      String    @default("NIO")

  competitorPrice Decimal? @db.Decimal(12,2)
  ourPrice        Decimal? @db.Decimal(12,2)
  priceIndex      Decimal? @db.Decimal(12,4)

  source        IndexSource @default(MANUAL)
  notes         String?

  createdAt     DateTime @default(now())

  @@unique([evaluationId, segment, slot])
  @@index([segment])
}

model AiEvaluation {
  id           String   @id @default(uuid())
  evaluationId String   @unique
  evaluation   Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  schemaVersion String
  modelName     String
  promptVersion String

  outputJson    Json

  latencyMs     Int?
  tokenCount    Int?

  errorCode     String?
  errorMessage  String?

  createdAt     DateTime @default(now())

  @@index([createdAt])
}

model AiFinding {
  id           String   @id @default(uuid())
  evaluationId String
  evaluation   Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  type         EvidenceType
  severity     Severity
  detail       String
  segment      Segment?

  tags         String[]

  createdAt    DateTime @default(now())

  @@index([evaluationId])
  @@index([type])
  @@index([severity])
}

model AiRecommendation {
  id           String   @id @default(uuid())
  evaluationId String
  evaluation   Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  priority     RecommendationPriority
  action       String
  rationale    String?
  ownerRole    Role?
  segment      Segment?

  createdAt    DateTime @default(now())

  @@index([evaluationId])
  @@index([priority])
}

model AuditLog {
  id         String     @id @default(uuid())
  actorId    String?
  actor      User?      @relation("AuditActor", fields: [actorId], references: [id])

  action     AuditAction
  entityType String
  entityId   String
  meta       Json?

  ip         String?
  userAgent  String?

  createdAt  DateTime   @default(now())

  @@index([entityType, entityId])
  @@index([action, createdAt])
}
